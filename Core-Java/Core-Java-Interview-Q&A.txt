Q) What is checked Exceptions
A) Checked exceptions are checked at compile-time. It means if a method is throwing a checked exception then it should handle the exception using try-catch block or it should declare the exception using throws keyword, otherwise the program will give a compilation error. It is named as checked exception because these exceptions are checked at Compile time.

There is no difference between compile time exceptions and checked exceptions

Q) What is Exception Propagation
A) If we dont want to handle the exception by using "try&catch" then we can propagate or fwd that exception to other method by using "throws" keyword on method level.
-> We use "throws" keyword to propagate the exception.
-> Unchecked Exceptions are by default propagated but checked Exceptions are need to be propagated.
-> Unchecked Exceptions like "NullPointerException" will be propagated by default if we dont handle in "try&catch" block.
-> if we use "try&catch" block, the Exception Propagation wont happen.

-> checked Exception will get detected at compile time. we can declare checked exception by using "throw" keyword.
ex:- throw new IOException()
->  These checked exceptions must be caught or declare to be thrown.
a) Exceptions must be caught by using "try&catch" block (or)
b) If we dont want to handle exceptions, then we can declare/throw exceptions/propagate the exception by using "throws" keyword like "throws IOException" on method level.

-> If we propagate and handle the Exception in same method, then will face Exception issue at run time. 
ex:-
----
void m3() throws IOException{
	try{
		m2();
	}catch(){
		io.printStackTrace();
	}
}

main(){
m3();
}

By above code, on method m3() we are trying to propagate the exception by "throws" keyword and also handling the Exception by using "try&catch" block in same m3() method, so in this case will get Exception at run time because, though we have handled the exception, we are using "throws" keyword to propagate the Exception.

Q) Difference between append and concat in java
A) 
Concat:-
--------
-> its belong to String class. concatenates one string to the end of another string.
-> concat() method takes only one argument of string and concatenates it with other string.
-> concat() method takes only string arguments, if there is any other type is given in arguments then it will raise an error.
-> concat() method throws NullPointer Exception when a string is concatenated with null
-> concat() method is better than the + operator because it creates a new object only when the string length is greater than zero(0) but the + operator always creates a new string irrespective of the length of the string.

append or +:-
-------------
-> + operator takes any number of arguments and concatenates all the strings.
-> + operator takes any type and converts to string type and then concatenates the strings.
-> + operator did not raise any Exception when the string is concatenated with null.
-> + operator creates a new String object every time irrespective of the length of the string.

Q) How to create custom Immutable class in java
A)  a)Make your class final
	b)Declare all instance variables with private and final keywords
	c)Say no to Setter Methods
	d)Initialize all variables in constructor
	e)perform cloning of mutable objects while returning from getter methods. (Some Disadvantages while performing cloning)
	
Ex-1:- Lets say below we have created our custom class,

//mutable class
public class Address {

    private String city;
    private String zip;
	
	//Setter and getters methods
	
}

public final class Employee {

    private final String name;
    private final Date doj; //mutable
    private final List<String> mobile;

    private final Address address;

    public Employee(String name, Date doj, List<String> mobile, Address address) {
        this.name = name;
        this.doj = doj;
        this.mobile = mobile;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public Date getDoj() {
        return doj;
    }

    public List<String> getMobile() {
        return mobile;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", doj=" + doj +
                ", mobile=" + mobile +
                ", address=" + address +
                '}';
    }

    public static void main(String[] args) {
        Address address=new Address("blr","1012");
        Employee employee=new Employee("Basant",new Date(),
                Arrays.stream(new String[]{"1234","5678"}).collect(Collectors.toList()), address);

        employee.getDoj().setDate(20);   // By this, we are able to modify the date. Immutable concept fails here.
        employee.getMobile().add("9010"); // By this, we are able to modify the date. Immutable concept fails here.
        employee.getAddress().setCity("Pune"); // Though Address class is made as immutable in Employee class, still Immutable concept fails here

        System.out.println(employee);


    }
}

Above, Though we have followed all rules to create Custom Immutable class, still printing output, will see the added values/objects will get added and Immutable rule fails here.

For Object, we can go with the clone and for List, we can create a new List, rather than return the actual reference.

Notes to acheive Immutable class for above Example. (Changes in code in above Example),

-> Rather than return the direct Object, we can simply do the clone. Below is the Syntax
from:
-----
public Date getDoj() {
        return doj;
}
To:-
----
public Date getDoj() {
        return (Date) doj.clone();
}

-> Rather than return the direct Object, we can simply return "Collections.unmodifiableList(mobile)". By this will get some Exception, because we are not allowing anyone to modify. But we dont want to give any Exception. To avoid this, we can simply return "new ArrayList<>(mobile);". Both "Collections.unmodifiableList(mobile)" and "new ArrayList<>(mobile);" can be followed, only difference is Exception will get.
from:
-----
public List<String> getMobile() {
        return mobile;
    }
To:-
----
public List<String> getMobile() {
        return new ArrayList<>(mobile);
}

-> Rather than return the direct/actual Object, create a new address object and get all the attributes.
from:
-----
public Address getAddress() {
        return address;
    }
To:-
----
public Address getAddress() {
        return new Address(address.getCity(),address.getZip());
}


Q) Which one is good to store password in Java ? String or char[] & why
A)  a)If we store our "passwords" in String, it may get stored in memory untill GC clears the memory.
	b)SCPA is used for reusability, there is a pretty  high chance that it will remain in memory for long duration.
	c)The 1 who have access to Memory Dump, can find the password in clear text
	d)Since Strings are Immutable, there are no way, contents of Strings can be changed because any change will produce new String.
	e)We can set our passwords in "char[]", we can still set to blank or zero. And by using Array, even if we print array, its content won't get displayed but its location will be visible.
	
Ex:-
String strPassword="Unknown";
char[] charPassword = new char[]{'U','n','k','n','o','w','n'};
System.out.println("String Password: "+ strPassword);
System.out.println("Character Password: "+ charPassword);

Output:-
--------
String Password: Unknown
Character Password: [C@110b53]

Q) Why wait(),notify() and notifyAll() methods are in Object Class not in Thread Class.
A) As every Object in Java has only 1 lock or monitor and "wait(),notify() and notifyAll()" are used for monitor sharing. These methods works on locks and locks are associated with onjects not the threads. And thats the reasaon all these 3 methods are in Object class.
(or)
Every Object is associated with monitor. Only 1 Thread can hold the monitor at a time. acquiring the object, monitor allow thread to hold lock on object. These methods are not called on the thread as it does not have its own lock as the monitor is with the object. wait() is called on the object to have the thread move to wait() state.
-> Similarly, "notify() and notifyAll()", is called on the Object to notify the waiting thread.


Q) What is Class loader in java and its types
A) Class Loaders are the Base class which has to be loaded before running or compiling any of our applications 
a) Bootsrap ClassLoader:- Its the base classes which is required to up and run the JVM. It runs all the classes available in rt.jar.
b) System ClassLoaded:- classes which is required like lang package which is present in rt.jar/lib.
c) Application ClassLoader:- classes which are there in your class which has to be compiled.


Q) Difference between path and class path
A)  a).Path is an environment variable which is used by the operating system to find the executables. Classpath is an environment variable which is used by the Java compiler to find the path, of classes.ie in J2EE we give the path of jar files.
b) .PATH is nothing but setting up an environment for operating system. Operating System will look in this PATH for executables. Classpath is nothing but setting up the environment for Java. Java will use to find compiled classes.
c) .Path refers to the system while classpath refers to the Developing Envornment.
d) In path we set the path of executables while in classpath we set path of jars for compiling classes.


Q) Which 1 is preffered to create Threads. Thread class or Runnable Interface
A) Implement the Runnable Interface, so that will have the option to extend the classes later on.

Q) When we face memory leak in java
A) -> Excessive use of static members
-> Unclosed Resources
-> Improper equals() and hashcode() Implementations
-> Excessive Session Objects
-> poorly written custome data structure.

static members:- These are not associated with any objects. Static Members have lifespan of almost application. whenever class is loaded in JVM at that time all static members allocated memory. It will remain in the memory untill the class loader become eligible for garbage collection.
