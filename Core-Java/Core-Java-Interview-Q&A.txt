Q) What is JRE, JDK and JVM
A) JDK:- JVM (Java Virtual Machine) is an abstract machine. It is called a virtual machine because it doesn't physically exist. 
-> It Provides a runtime environment in which Java bytecode can be executed. 
-> It can also run those programs which are written in other languages and compiled to Java bytecode.
-> It Performs the tasks such as Loads code, Verifies code, Executes code and Provides runtime environment.

JRE:- Java Runtime Environment(JRE) is a set of software tools which are used for developing Java applications. 
-> It is used to provide the runtime environment. 
-> It is the implementation of JVM. It physically exists. 
-> It contains a set of libraries like ".jar" + other files that JVM uses at runtime.

JDK:- The Java Development Kit (JDK) is a software development environment which is used to develop Java applications and applets. 
-> It physically exists and It contains JRE + development tools.(Ex:- javac and java).
-> The JDK includes JRE, interpreter/loader (java), a compiler (javac), an archiver (jar) etc. and other development tools.

Note:- Typically, We need only JRE to run Java programs on your machine or browser. However, if we want to develop an application, debug and do Java programming, you will need JDK.

Q) How many ways we can create String Object in Java.
A) 2 ways:- By String Literal and By "new" keyword.
String Literal:- String str = "Vikas";              // 1 Object will be created in SCP Area.
New Keyword:-    String str = new String("Vikas");  //2 Objects will be created. 1 in Heap and 1 in SCPA(String Constant Pool Area). But it will refers to Heap Area Object.

String str = "Vikas";
str.concat(" Singh");
System.out.println(str); //str still points to "Vikas".
Output:- Vikas  // Here Vikas is not changed, but a new object is created with "Vikas Singh" in SCPA. Thats y String is Immutable. Now SCPA has 2 Objects "Vikas" and "Vikas Singh".

-> But If we assign explicitly to the referene variable, then it will refer to "Vikas Singh". Below is Example,
Ex:- String str = "Vikas";
     str = str.concat(" Singh");
     System.out.println(str);
     Output:- Vikas Singh  // Now str points to "Vikas Singh". Please Notice, "Vikas" Object is still not modified.

Q) Difference Between ClassNotFoundException and NoClassDefFoundError in Java?
A) ClassNotFoundException:- ClassNotFoundException comes when we try to load a class at run-time using Reflection and if those class files are missing then application or program thrown with ClassNotFoundException Exception. 
There is nothing to check at compile-time since it is loading the class at run-time.
Example:-
---------
public class ClassNotFoundExceptionTest {
   public static void main(String[] args) {
      try {
         Class.forName("Test");
      } catch (ClassNotFoundException cnfe) {
         System.err.println("You are trying to search for a class is not existing. "+cnfe);
      }
   }
}

NoClassDefFoundError:- NoClassDefFoundError is thrown when a class has been compiled with a specific class from the classpath but if same class not available during run-time. 
Missing JAR files are the most basic reason to get NoClassDefFoundError.
Example:-
---------
class Test1 {
   public void show() {
      System.out.println("show() method called");
   }
}
public class Test2 {
   public static void main(String[] args) {
      Test1 t = new Test1();
      t.show();
   }
}

-> When we compile both the classes we will be getting two class files Test1.class and Test2.class, while running Test2 class just remove the Test1.class file then we will be getting NoClassDefFoundError as below

Q) What is checked Exceptions
A) Checked exceptions are checked at compile-time. It means if a method is throwing a checked exception then it should handle the exception using try-catch block or it should declare the exception using throws keyword, otherwise the program will give a compilation error. It is named as checked exception because these exceptions are checked at Compile time.
-> There is no difference between compile time exceptions and checked exceptions
-> By default, Checked Exceptions are not forwarded in calling chain (propagated)
ex:- void m(){  
    throw new java.io.IOException("device error"); //checked exception  
  }

Q) What is Exception Propagation
A) If we dont want to handle the exception by using "try&catch" then we can propagate or fwd that exception to other method by using "throws" keyword on method level.
-> We use "throws" keyword to propagate the exception.
-> Unchecked Exceptions are by default propagated but checked Exceptions are need to be propagated.
-> Unchecked Exceptions like "NullPointerException" will be propagated by default if we dont handle in "try&catch" block.
-> if we use "try&catch" block, the Exception Propagation wont happen.
ex:-  void m1() throws IOException {
	int a = 10/0; // UnChecked Exception
      }

-> checked Exception will get detected at compile time. we can declare checked exception by using "throw" keyword.
ex:- throw new IOException()
->  These checked exceptions must be caught or declare to be thrown.
a) Exceptions must be caught by using "try&catch" block (or)
b) If we dont want to handle exceptions, then we can declare/throw exceptions/propagate the exception by using "throws" keyword like "throws IOException" on method level.

-> If we propagate and handle the Exception in same method, then will face Exception issue at run time. 
ex:-
----
void m3() throws IOException{
	try{
		m2();
	}catch(){
		io.printStackTrace();
	}
}

main(){
m3();
}

By above code, on method m3() we are trying to propagate the exception by "throws" keyword and also handling the Exception by using "try&catch" block in same m3() method, so in this case will get Exception at run time because, though we have handled the exception, we are using "throws" keyword to propagate the Exception.

Q) What is Volatile in java
A) Volatile keyword is used to modify the value of a variable by different threads. It is also used to make classes thread safe. It means that multiple threads can use a method and instance of the classes at the same time without any problem. The volatile keyword can be used either with primitive type or objects.

Q) What is Synchronization
A) Synchronization in java is the capability to control the access of multiple threads to any shared resource. In the Multithreading concept, multiple threads try to access the shared resources at a time to produce inconsistent results. The synchronization is necessary for reliable communication between threads.

Q) What is Encapsulation
A) Encapsulation is a mechanism through which we can wrap the data members(variables and methods) of class in a single Unit.
-> Declare variables as private // Data Hiding to acheive Encapsulation
-> Declare methods as public to access the variables. // Data Abstraction
-> To Have better control on class on how the class should behave.

Q) What is Covariant Return Type
A) The covariant return type specifies that the return type subclass may vary against return type of super class. 
-> the return type of the get() method of A class is A but the return type of the get() method of B class is B. Both methods have different return type but it is method overriding. This is known as covariant return type.

Q) Difference between append and concat in java
A) 
Concat:-
--------
-> its belong to String class. concatenates one string to the end of another string.
-> concat() method takes only one argument of string and concatenates it with other string.
-> concat() method takes only string arguments, if there is any other type is given in arguments then it will raise an error.
-> concat() method throws NullPointer Exception when a string is concatenated with null
-> concat() method is better than the + operator because it creates a new object only when the string length is greater than zero(0) but the + operator always creates a new string irrespective of the length of the string.

append or +:-
-------------
-> + operator takes any number of arguments and concatenates all the strings.
-> + operator takes any type and converts to string type and then concatenates the strings.
-> + operator did not raise any Exception when the string is concatenated with null.
-> + operator creates a new String object every time irrespective of the length of the string.

Q) How to create custom Immutable class in java
A)  a)Make your class final
	b)Declare all instance variables with private and final keywords
	c)Say no to Setter Methods
	d)Initialize all variables in constructor
	e)perform cloning of mutable objects while returning from getter methods. (Some Disadvantages while performing cloning)
	
Ex-1:- Lets say below we have created our custom class,

//mutable class
public class Address {

    private String city;
    private String zip;
	
	//Setter and getters methods
	
}

public final class Employee {

    private final String name;
    private final Date doj; //mutable
    private final List<String> mobile;

    private final Address address;

    public Employee(String name, Date doj, List<String> mobile, Address address) {
        this.name = name;
        this.doj = doj;
        this.mobile = mobile;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public Date getDoj() {
        return doj;
    }

    public List<String> getMobile() {
        return mobile;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", doj=" + doj +
                ", mobile=" + mobile +
                ", address=" + address +
                '}';
    }

    public static void main(String[] args) {
        Address address=new Address("blr","1012");
        Employee employee=new Employee("Basant",new Date(),
                Arrays.stream(new String[]{"1234","5678"}).collect(Collectors.toList()), address);

        employee.getDoj().setDate(20);   // By this, we are able to modify the date. Immutable concept fails here.
        employee.getMobile().add("9010"); // By this, we are able to modify the date. Immutable concept fails here.
        employee.getAddress().setCity("Pune"); // Though Address class is made as immutable in Employee class, still Immutable concept fails here

        System.out.println(employee);


    }
}

Above, Though we have followed all rules to create Custom Immutable class, still printing output, will see the added values/objects will get added and Immutable rule fails here.

For Object, we can go with the clone and for List, we can create a new List, rather than return the actual reference.

Notes to acheive Immutable class for above Example. (Changes in code in above Example),

-> Rather than return the direct Object, we can simply do the clone. Below is the Syntax
from:
-----
public Date getDoj() {
        return doj;
}
To:-
----
public Date getDoj() {
        return (Date) doj.clone();
}

-> Rather than return the direct Object, we can simply return "Collections.unmodifiableList(mobile)". By this will get some Exception, because we are not allowing anyone to modify. But we dont want to give any Exception. To avoid this, we can simply return "new ArrayList<>(mobile);". Both "Collections.unmodifiableList(mobile)" and "new ArrayList<>(mobile);" can be followed, only difference is Exception will get.
from:
-----
public List<String> getMobile() {
        return mobile;
    }
To:-
----
public List<String> getMobile() {
        return new ArrayList<>(mobile);
}

-> Rather than return the direct/actual Object, create a new address object and get all the attributes.
from:
-----
public Address getAddress() {
        return address;
    }
To:-
----
public Address getAddress() {
        return new Address(address.getCity(),address.getZip());
}


Q) Which one is good to store password in Java ? String or char[] & why
A)  a)If we store our "passwords" in String, it may get stored in memory untill GC clears the memory.
	b)SCPA is used for reusability, there is a pretty  high chance that it will remain in memory for long duration.
	c)The 1 who have access to Memory Dump, can find the password in clear text
	d)Since Strings are Immutable, there are no way, contents of Strings can be changed because any change will produce new String.
	e)We can set our passwords in "char[]", we can still set to blank or zero. And by using Array, even if we print array, its content won't get displayed but its location will be visible.
	
Ex:-
String strPassword="Unknown";
char[] charPassword = new char[]{'U','n','k','n','o','w','n'};
System.out.println("String Password: "+ strPassword);
System.out.println("Character Password: "+ charPassword);

Output:-
--------
String Password: Unknown
Character Password: [C@110b53]

Q) Why wait(),notify() and notifyAll() methods are in Object Class not in Thread Class.
A) As every Object in Java has only 1 lock or monitor and "wait(),notify() and notifyAll()" are used for monitor sharing. These methods works on locks and locks are associated with onjects not the threads. And thats the reasaon all these 3 methods are in Object class.
(or)
Every Object is associated with monitor. Only 1 Thread can hold the monitor at a time. acquiring the object, monitor allow thread to hold lock on object. These methods are not called on the thread as it does not have its own lock as the monitor is with the object. wait() is called on the object to have the thread move to wait() state.
-> Similarly, "notify() and notifyAll()", is called on the Object to notify the waiting thread.


Q) What is Class loader in java and its types
A) Class Loaders are the Base class which has to be loaded before running or compiling any of our applications 
a) Bootsrap ClassLoader:- Its the base classes which is required to up and run the JVM. It runs all the classes available in rt.jar.
b) System ClassLoaded:- classes which is required like lang package which is present in rt.jar/lib.
c) Application ClassLoader:- classes which are there in your class which has to be compiled.


Q) Difference between path and class path
A)  a).Path is an environment variable which is used by the operating system to find the executables. Classpath is an environment variable which is used by the Java compiler to find the path, of classes.ie in J2EE we give the path of jar files.
b) .PATH is nothing but setting up an environment for operating system. Operating System will look in this PATH for executables. Classpath is nothing but setting up the environment for Java. Java will use to find compiled classes.
c) .Path refers to the system while classpath refers to the Developing Envornment.
d) In path we set the path of executables while in classpath we set path of jars for compiling classes.


Q) Which 1 is preffered to create Threads. Thread class or Runnable Interface
A) Implement the Runnable Interface, so that will have the option to extend the classes later on.

Q) When we face memory leak in java
A) -> Excessive use of static members
-> Unclosed Resources
-> Improper equals() and hashcode() Implementations
-> Excessive Session Objects
-> poorly written custome data structure.

static members:- These are not associated with any objects. Static Members have lifespan of almost application. whenever class is loaded in JVM at that time all static members allocated memory. It will remain in the memory untill the class loader become eligible for garbage collection.
