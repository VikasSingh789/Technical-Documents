Q) How Spring MVC Works
A) A Spring MVC provides an elegant solution to use MVC in spring framework by the help of DispatcherServlet. Here, DispatcherServlet is a class that receives the incoming request and maps it to the right resource such as controllers, models, and views.

Step 1 - When the client (browser) sends an HTTP request to a specific URL. The DispatcherServlet of Spring MVC receives the request.
Step 2 - DispatcherServlet consult to HandlerMapper to identify which controller is responsible to handle the HTTP request.
Step 3 - HandlerMapper selects the controller which is mapped to the incoming request URL and returns the (selected Handler) and Controller details to DispatcherServlet.
Step 4 - Now DispatcherServlet knows which controller is responsible to process the request so DispatcherServlet will forward that request to the corresponding controller to process the request.
Step 5 - Now the Controller process the request, validates the request, and creates a model with data. Finally, the Controller returns the logical name of view and model to the DispatcherServlet.
Step 6 - DispatcherServlet consult ViewResolver to resolve a logical view with the physical view that exists in the application.
Step 7 - ViewResolver responsible to map logical view with actual view and return the actual view details back to the DispatcherServlet.
Step 8 - Now DispatcherServlet sends the view and model to the View component.
Step 9 - The View component merge view and model and forms a plain HTML output. Finally, the View component sends HTML output back to the DispatcherServlet.
Step 10 - The DispatcherServlet finally sends HTML output as a response back to the browser for rendering.

Q) Difference between @Qualifier and @Primary
A) @Primary defines a default value and bean marked with this annotation will be used unless otherwise indicated. 
   @Qualifier annotation is specific and is used when a particular bean is needed.
   
Q) Difference between @Inject and @Autowired
A) @Autowired is defined by Spring Framework but @Inject came from "Dependency Injection for Java" (JSR-330)".
-> By default the dependency injection for @Autowired must be fulfilled because the value of required attribute is true by default. We can change this behavior by using @Autowired(required=false). In this case if bean is not found for dependency injection, it will not throw error.
 But @Inject annotation has no required attribute. Therefore, if the dependencies will not be found - will be thrown an exception.
-> @Qualifier can be used in case of ambiguity while working with @Autowired and we use @Named Qualifier while working with @Inject.
-> @Inject is portable and can be used in spring framework and as well as with some other application. But @Autowired will work only with Spring Framework.

Q) What is Spring AOP
A)  Spring AOP enables Aspect-Oriented Programming in spring applications. In AOP, aspects enable the modularization of concerns such as transaction management, logging or security that cut across multiple types and objects (often termed crosscutting concerns).
	a) Aspect:- Aspect is a class
	b) Class contains some methods. These methods are called as Advice.
	c) All methods contains some logic, which is called "cross cutting concerns" that we need to segregate from business logic.
	d) Joinpoint:- A joinpoint always represents a method execution.
	e) These Methods will execute only on some particular condition. These condition is known as pointcut.

Types of Advice:- Before, After, After returning, After throwing advice and Around Advice.
	
AOP has 2 types of implementation.
a) XML configuration files
b) AspectJ Orientation Files.


Q) difference between Pathvariable and ReqParam.
A) If we are using Pathvariable and we are not  giving the input, then will get "404" Error. If we are using Pathvariable, its Mandatory to give the input otherwise it will give error.
Incase of ReqParam, the input is Optional. we wont get any exception.

Q) What is difference between @Bean and @Component in Spring
A) a) @Component auto detects and configures the beans using classpath scanning whereas @Bean explicitly declares a single bean, rather than letting Spring do it automatically.
b) @Component is a class level annotation whereas @Bean is a method level annotation and name of the method serves as the bean name.
c) @Bean annotation has to be used within the class which is annotated with @Configuration whereas we dont need @Configuration while using @Component.
d) We cannot create a bean of a class using @Component, if the class is outside spring container whereas we can create a bean of a class using @Bean even if the class is present outside the spring container.
e) @Component has different specializations like @Controller, @Repository and @Service whereas @Bean has no specializations.

Q) When should we use @Bean?
A) @Bean is an annotation based configuration and hence is used in @Configuration based class. This is an explicit way of defining a bean
Sometimes automatic configuration is not an option. When? Let's imagine that you want to wire components from 3rd-party libraries (you don't have the source code so you can't annotate its classes with @Component), so automatic configuration is not possible.

Scenario : You downloaded a jar file from GitHub and it is not using Spring. The jar file is a simple and basic java program. Your app wants to use this third-party jar file but since your application is using Spring while the third party jar is not, you will have to write new() keyword to access the functionalities. You want to wire the third party classes.

Say your class name is MyClass.java and you want to use ThirdPartyClass.java. In this case if you write

public class MyClass{
   .....
	 @Autowired
	 ThirdPartyClass thirdPartyClass;
	 
}

Your code will throw NullPointerException if you try and access any method of class object thirdPartyClass. In this scenario, you should use @Bean.

-> If you want to use third-party classes or jar then use @Bean.
-> If you want to use a third party class or jar that is not written using Spring Component then use @Bean.

Q) What is ACID in SpringBoot
A) ACID is an acronym that stands for atomicity, consistency, isolation, and durability.
-> Atomicity describes an all or nothing principle. Either all operations performed within the transaction get executed or none of them executed.
-> If anything or any transaction goes wrong, we can rollback the changes from Database. With this we can avoid or ignore Data inconsistency in our application.

Q) What is Atomicity
A) Atomicity − A transaction should be treated as a single unit of operation, which means either the entire sequence of operations is successful or unsuccessful. 
-> Consistency − This represents the consistency of the referential integrity of the database, unique primary keys in tables, etc.

Q) What is JDBC Template
A) JDBCTemplate is a class in Spring which is used to execute the queries. It also provides different methods for querying/retrieving data from the database.
-> JDBC is not an ORM tool, it does not represent any rows as objects in DB whereas Hibernate does that.
-> If we are not using Hibernte in our Project, we can use JDBCTemplate to query and retrive the data from Database.

Methods:-
--------
jdbcTemplate.query(queryString), jdbcTemplate.queryForList(queryString) and jdbcTemplate.update(queryString).


